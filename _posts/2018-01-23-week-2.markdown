---
layout: post 
title:  "Week 2"
date:   2018-01-23 17:00:00 -0500
categories: dada 
---

Last week’s lectures focused primarily on malware analysis. This week, Mr. Beek broadened the scope of his discussion to _forensic computing_, the process of “identifying, preserving, analyzing, and presenting digital evidence in a legally acceptable way.” Mr. Beek has significant experience as a forensic analyst, and he wove a number of interesting personal anecdotes into this week's course material. These were Mr. Beek's last lectures with us, and he ended his tenure with a mock forensic analysis, tying concepts from the first two weeks together into a single assignment.

## Concepts 

Forensic computing is a broad field, although forensic analysts and incident response teams are typically called in to assist with a few major case types: fraud, IP theft, hacker intrusions or data breaches, inappropriate usage of content (such as accessing inappropriate websites at work), and child exploitation. At times, analysts are hired to perform “eDiscovery” in support of civil or criminal litigation. Generally, however, all forensic analysis can be separated into three primary categories: 

-	live forensics, or the process of evidence collection on a live, functional system,
-	post-mortem forensics, in which computer memory or disk contents are analyzed for evidence after a suspect system has been captured and deactivated, and
-	Network-based forensics, or analysis of the network behavior originating from or destined for a target system or device.

Mr. Beek noted that live forensics is becoming more popular as investigators and police forces become more computer-savvy; the process of shutting down a computer can be extremely costly in terms of evidence collection. Nonetheless, crime scenes are often dangerous, and the decision to shut down any live analysis and remove evidence from the crime scene is entirely up to the chief forensic analyst. 

He also mentioned that forensic analysts _must_ develop the ability to explain their findings to a layperson, such as a judge or lawyer. As an analyst’s work is often presented as legal evidence, it needs to be air-tight, as impervious as possible to attack or questioning from a defense attorney or judge. Most computer forensics experts are not trained in legal matters, and so there is often a learning curve for new analysts as they prepare legal documentation and legally-sound lines of reasoning.

Forensic analysts and investigators must be keenly aware of best practices in data collection and evidence handling. An investigator should strive, at all times, to record everything: the time at which they start analysis (local time and system time), what they observe, which steps they took (and when), and so forth. Investigators and analysts typically maintain a forensic journal, following legal standards for documentation (pen and paper, no skipped lines). In conducting their, work, forensic analysts must limit data loss to an extreme extent - any data lost can compromise evidence or call into question the veracity of an analyst's report. 

The lecture included a brief discussion about the sheer variety of devices that a forensic analyst might encounter – computer forensics are not limited to laptops or desktops. Smartphones, USB sticks, car GPS systems, and even smart TVs are sources of forensic data. Analysts often need to devise clever ways to access this data without disrupting it – preserving memory is paramount.

Mr. Beek introduced the term _triage_, which in forensic analysis refers to the process of proving a conclusion in multiple ways, using different analytical tactics. In a database attack, for instance, one might be able to verify the success of the attack by analyzing registry modification, system log files, and SQL logs. Arriving at the same conclusion in multiple ways increases the soundness of an investigator’s analysis. 

Preservation of evidence integrity is a tenet common to any forensic investigation; in computer forensics, this can be especially tricky. When performing postmortem analysis of captured disks or partitions, investigators typically perform the following steps, in order, to guarantee that any evidence collected will be admissible (that is, deemed legitimate in the opinion of a court of law):

-	Create a cryptographic (MD5, SHA1) hash of the image, disk, or partition.
-	Create a bit-image copy; all analysis will use this copy.
-	Create another MD5/SHA1 hash of this copy, verifying that it is identical to the hash of the original disk. 
-	Lock the original image or disk in a secure room, and maintain surveillance or security measures preventing unauthorized access to that room.

In a postmortem analysis, it is of utmost importance to hash the original disk before doing anything else – any action in the original disk will contaminate it, possibly compromising valuable evidence. Typically, the process of copying a drive is accomplished using a device called a Write Blocker, which essentially prevents any inadvertent or unintended writes to the original drive as it is being copied. 

Mr. Beek continued with a discussion of the incident response process, presenting a flow-chart describing the steps that an incident response team might take in investigating, analyzing, and remediating a malware attack or other cybercrime. An important – and, perhaps, overlooked – step is evaluation; taking time to evaluate a particular incident response effort allows teams to better prepare for future threats. Incident response teams have to stay sharp: they are often called in when time is of the essence, and so practice (in the form of “Red Team / Blue Team” training scenarios) and adequate tool preparation are absolutely necessary. Incident responders must also learn to communicate effectively; often, nervous executives are hovering over the response team, looking for answers or updates – a skilled incident responder knows how to convey progress in a clear, non-technical manner. Dedicated incident response teams are a luxury, however, and it is more often the case that ad-hoc, cobbled-together teams of subject matter experts are brought together to neutralize a live threat. 

In investigating an APT attack, forensic investigators can look to the APT-Kill-Chain, using it as a point of reference to determine what sort of evidence might be present. Attacker reconnaissance might be captured in external or internal firewall logs or IPS logs; attacker actions during the Installation, Command and Control, and Delivery phases could be captured by reviewing memory dumps, registry modifications, or prefetch-files (similar to our static analysis last week). The sheer amount of potential data presents an issue – it is time-consuming to sort through, and the variety of operating systems and equipment vendors in most corporate computer systems may require a plethora of specialized analysis tools. However, one of the most complex challenges is in normalizing a timeline of the attack; as the number of devices involved in an attack increases, the challenge of normalizing their system times to produce a unified sequence of events becomes significant. Again, forensic investigators must take great care to ensure that their analysis will stand up to legal scrutiny, and that they are following established investigation guidelines at all times.

To illustrate the necessity of minimizing evidence contamination, Mr. Beek discussed _Locard’s Exchange Principle_: when two objects contact each other, evidence is left. One cannot interact with a live system without affecting it in some manner, and so it is imperative to keep detailed, organized notes documenting one’s analytical process.

[RFC 3227][rfc-3227], “Guidelines for Evidence Collection and Archiving”, provides an overview of Guiding Principles, or general best practices in evidence collection. These include keeping detailed notes, tracking the difference between the system clock and UTC, prioritizing collection over analysis, and minimizing the changes to data as it is being collected. Notably, it also defines an Order of Volatility for information, which mirrors the order in which forensic evidence should be taken. Extremely volatile elements such as CPU register or cache contents should be collected first, followed by routing tables, ARP caches, process tables, and memory; collection should continue with temporary file systems, disks, remote logging and monitoring data, physical configurations and network topology, and, finally, by archival media or backup disks. Intuitively, it is most important to collect the most volatile data first, as any modification to the system (including a shutdown) is likely to destroy it. 

Mr. Beek’s lectures continued with a discussion of the tools used by computer forensics analysts, in particular FTK Imager and Volatility. FTK Imager is a utility used for disk imaging; it automatically calculates md5 hash values, validates pre- and post-copy checksums, and provides a directory listing in the copied disk image. It’s a more user-friendly, GUI-based tool, although as a result it leaves a greater footprint in memory; this can destroy useful evidence. In practice, professionals often use lower-impact tools to accomplish this task. It’s also important to remember to never install FTK Imager (or any other piece of software) on the target’s computer – this can invalidate any evidence collected, as the integrity of the data collected can easily be called into question. If data is to be collected while the target system is running, an imaging program like FTK Imager could instead be executed via a USB stick or flash drive attached to the target’s computer. 

Once a disk image is obtained, forensic researchers and analysts often analyze and glean information from the image using tools like Volatility. Volatility is massive in scope, containing dozens of plugins that extend its basic disk image analysis functionality. It is run from the command-line, and a typical workflow involves redirecting its output to a text file for detailed analysis. Mr. Beek demonstrated its basic functionality, running imageinfo to obtain system info pertinent to the image under analysis – its operating system, number of CPU cores, and so forth. This output can, in turn, be used in certain plugins that require this information. He continued with psscan, dlllist, netscan, deskscan, getsids, mftparser, and timeliner, which will be discussed more fully in “What I Learned”, below.

Knowing how to use all of these plugins won’t accomplish much if one doesn’t know what to look for, and so Mr. Beek continued with a brief discussion of the key artifacts that are analyzed in many forensic investigations. In particular, he discussed what can be obtained from a memory snapshot, including keystrokes, wireless keys, window contents, running device drivers, usernames, and passwords, all of value to the forensic investigator. He then introduced the Windows registry, a hierarchical database of key-value pairs that records most of what Windows does; this includes configuration settings, hardware device information, application data, insertion times for USBs, and so forth. RegEdit is a Windows tool that can be used to search through the registry and observe changes. Important clues can be found in the Run keys, which are used to determine which programs start when the operating system boots; most malware modifies these keys in an attempt to self-perpetuate on the target’s system. Other important data, such as lists of last-used files, typed URLs, MAC addresses of connected devices, and search histories can be found in the registry. Outside of the registry, other key artifacts include system restore points, hibernation files, .LNK files, pagefile.sys, and crash-dump files. An investigator must often combine data from multiple sources to triage and harden their conclusions, and so it is often to look through many different files for the same traces of activity.

Mr. Beek’s lectures concluded with a brief discussion of data recovery and data carving. Once a file is deleted, it is not immediately overwritten; the start and end “flags” used to identify it as a file, however, are removed, allowing it to be overwritten as needed by the operating system. Many file types are identifiable by the sequence of characters that begin their headers – PE files always start with “MZ”, and JPEG files always start with `0xFFD8`. Data carving software looks through a target disk for these character sequences in deleted-but-intact files. Once found, these previously-deleted files are “carved out” and reconstituted, allowing for further analysis. An incredible amount of information can be found by carving out deleted files – Mr. Beek mentioned that smartphones typically retain deleted material for a significant amount of time, and that long-deleted text messages, app data, and so forth can be found fairly easily, even after the SD card is removed. This segment concluded with a demonstration of the photorec software, which will be discussed in more detail below.

This week’s activities were capped with a fun forensic analysis challenge, which I attempted in an effort to internalize the lecture material. 

## What I Did, and What I Learned

This week’s content was particularly interesting to me, as it seems to exist at the intersection of low-level systems programming, clever programming tricks, and deep, detailed data analysis. I enjoyed Mr. Beek’s tales of life as a forensic investigator, which really brought life to the lectures. The tools introduced were fascinating, too – once this week’s work is finished, I’m planning to download a copy of photorec on my home computer to see what I can find. 

To a certain extent, I’m playing catch-up with a lot of the more detailed Operating Systems material presented in Mr. Beek’s lectures; intuitively, I know what a disk image is, how an OS mounts a disk, how the Windows registry works, and what sort of information might be contained in a master boot record, but I would not be able to explain any of these topics in a detailed or nuanced manner. As I would later perform forensic analysis on a disk image provided by the instructor, I decided to begin by reviewing some of these topics to ensure that I knew what to look for, and how find it. 

Reading through RFC 3227 was interesting; its discussion of evidence collection practices closely matched Mr. Beek’s lecture material, and the overview of legal considerations was a handy summary of the requirements for a piece of evidence to be considered valid. Through coursework and my day job, I’m used to performing detailed analyses, but I’ve never considered what sort of steps I might need to take to perform a forensic analysis – the level of intensity and rigor required to create a legally defensible document is a step beyond what I’m used to. 

I followed along with Mr. Beek’s FTK Imager and Volatility labs in an effort to become more familiar with their use. I found Volatility to be especially fun to use, given its versatility – the amount of information that can be gleaned through different Volatility plugins is incredible. I’m a sucker for programs run from the command line, too.

I started with the FTK Imager tutorial, following along with Mr. Beek’s walkthrough and creating a memory dump of our virtual machine using the software. Here, we dumped memory to our local machine just to allow ourselves some practice, but in a real forensics case, this would be a disastrous step, as doing so significantly modifies the state of the computer from which the dump is being taken. A safer step might be to instead store the memory dump in a network share. I followed along as Mr. Beek discussed proper naming techniques, as most forensic or malware investigations are identified by a codename, target computer serial number, and so forth. I continued by practicing with the “Add Evidence Item” feature, mounting a physical disk (the VM’s hard drive, in this case) in a read-only fashion that allowed me to inspect its contents without modifying them. This mimics the process than an investigator might use to inspect a remote drive, once a write blocker is in place. Following along with Mr. Beek, I found the Master File Table (MFT), which FTK Imager allows the user to export individually. The [MFT][mft] stores data about every file on the file system volume - an invaluable tool in a forensic investigation.

<figure>
    <img src="/assets/img/week2/ftk-imager.png">
    <figcaption>Finding MFT using FTK Imager</figcaption>
</figure>

Finally, Mr. Beek demonstrated the process of creating a disk image with FTK Imager, mentioning that the same naming conventions applied here as with the memory dump - note a project codename, serial number of the computer being investigated, and so on. 

I next followed along with the Volatility lab, taking the example memory dump provided for us and performing basic analysis on its content. I began by renaming the volatility executable to `volatility.exe` and entering the command `volatility.exe --f <mem-dump> imageinfo` from the DOS prompt. This generated basic information about the memory dump: here, I noticed that the image profile matches Windows 7 SP0 or SP1. Importantly, I also noticed the image date and time of January 6th, 2015; this would be very important to mark in a real forensic analysis. 

<figure>
    <img src="/assets/img/week2/volatility-getimageinfo.png">
    <figcaption>Running imageinfo with Volatility</figcaption>
</figure>

For now, I continued with the lab, using psscan to obtain a list of hidden or terminated processes in the image. This was accomplished by entering the command 
`volatility.exe –f <mem-dump> --profile=Win7SP0x86 psscan` in the command prompt. A few familiar processes appeared:
	
<figure>
    <img src="/assets/img/week2/volatility-psscan.png">
    <figcaption>Output of Volatility's psscan plugin</figcaption>
</figure>

Notice the `evil.exe` and `svchest.exe` processes running in the image; these are the familiar malware programs from Lab 1. The number in the following column marks the process’s own process ID, and the number in the column after that indicates the parent process’s PID. A detailed analysis could involve creating a sort of tree from this information, identifying the pattern of parent and child processes created. 

I continued this exercise by investigating the dlllist, netscan, deskscan, and getsids plugins, redirecting output to an appropriately-named text file. dlllist displays the loaded DLLs for a given process, and is run with the command `volatility.exe –f <mem-dump> --profile=WinSP0x86 –dlllist –p <pid>`, where pid is the ID of the target process.

netscan provides a list of network activity; after running Volatility with this plugin, I was able to see all of the network activity to and from the target computer, including the activity generated by evil.exe:

<figure>
    <img src="/assets/img/week2/network.png">
    <figcaption>Output of Volatility's netscan plugin</figcaption>
</figure>

I continued following along with Mr. Beek, capturing desktops data with deskscan;  this command “enumerates desktops, desktop heap allocations, and associated threads” (the [Volatility Labs Blog][vol-blog]). As the Volatility Labs blog notes, malware will often launch itself or other applications in a different desktop, preventing the user from seeing the program being launched. Many ransomware attacks work by locking the user out of the own desktop.I obtained a list of security identifiers (or, SIDs) for `evil.exe` with getsids. As stated in [the Volatility documentation][vol-docs], Getsids can be used to identify processes that have doctored with privileges, as well as which processes belong to specific users. 

I continued by toying with the Volatility plugins mftparser and timeliner. timeliner (`volatility.exe –f <mem-dump> --profile=Win7SP0x86 mftparser --output=body`) is very useful for establishing a timeline of events in a forensic analysis. The timeliner plugin is more expansive, providing an extremely detailed timeline of running processes on the target memory dump. 

I executed this command on the sample memory dump provided to us, redirecting the command’s output to a text file for easy analysis. The output is somewhat like that produced by Windows Sysinterals’s Process Monitor; there is a series of columns with identifying data for each process, network connection, thread, PE timestamp, and so forth:

<figure>
    <img src="/assets/img/week2/timeliner.png">
    <figcaption>Output of Volatility's timeliner plugin</figcaption>
</figure>

As one might suspect, mftparser (`volatility.exe –f <mem-dump> --profile=Win7SP0x86 mftparser --output=body`) carves out the Master File Table from the image, and parses it in an effort to produce a detailed list of files in the MFT. Results can be redirected to a text file, and imported into Excel or similar for analysis. I called mftparser on the example memory dump provided to us, and observed the results:

<figure>
    <img src="/assets/img/week2/mftparser.png">
    <figcaption>Output of Volatility's mftparser plugin</figcaption>
</figure>

This document will contain a detailed history of what happened on the system – registry modifications, file names, changes to files, and so forth. 

My final task before the challenge was to investigate data recovery and data carving with photorec. Following along with Mr. Beek, I used the photorec software, along with OSFMount, to carve deleted data from a mounted sample disk image (`11-carve-fat.dd`, provided with the course material). 

First, OSFMount was used to mount the disk image to a drive; following along, `11-carve-fat.dd` was mounted to `E:\`. Next, I started photorec, and was greeted with the following welcome screen:

<figure>
    <img src="/assets/img/week2/photorec-menu.png">
    <figcaption>Photorec opening screen</figcaption>
</figure>

Using the program’s menu interface, I chose to recover files from `E:\`, selected, entered “unknown” for partition, “Other” for file system type, and chose to recover all known file types. After selecting the location to store the carved files, I observed this success message:

<figure>
    <img src="/assets/img/week2/photorec.png">
    <figcaption>Photorec completion message</figcaption>
</figure>


The output of photorec – discovered files – were saved in `C:\carving`; here, I noticed that a number of deleted files had been recovered, including .doc, .html, .jpeg, and .wav files. 

<figure>
    <img src="/assets/img/week2/photorec-dir.png">
    <figcaption>Directory of discovered files</figcaption>
</figure>

After looking through the content of this folder (sadly, Word isn’t on our VM, meaning I couldn’t open `f0000281_Nick_is_a_pretty_man…..doc`), I proceeded to this week’s Final Challenge.


## The Final Challenge

Mr. Beek presented a final (mock) forensics challenge: we were given a disk image, and told that it had been made from a USB stick intercepted from a North Korean defector caught near the border with South Korea. Using computer forensics best practices, along with the tools that we had practiced using earlier this week, our analysis needed to answer the following questions:

1.	What is/are the cyber-target(s) found on the USB stick?
2.	Investigate possible malware, and describe how it works.
3.	Display the list of usernames/passwords.
4.	Note the offset value at which we found them.
5.	Which relevant files were deleted? Can we replicate them?
6.	What strategy would we advise to our targets?

After giving us a few hints regarding where to look, we were set loose in an effort to collect evidence.

### Investigation

1/23/18, 7:03pm EST local time (UTC-0500). The Virtual Machine was activated, and the system time in the VM was 1/23/2018, 4:12pm, UTC-0800. From here onward, all time marks will reference the time in the VM, unless the relative difference between local and system time changes. 

I downloaded the USB image, `Image_USB_Mayflower.001`, from the network share, copying it to `C:\mayflower`. I then used OSFMount to mount the image as the `E:\` drive. In mounting the image, I selected the "mount as removable media" option to ensure that I could read the content of the USB drive from which the image was created. For now, I chose to mount the entire image, not just the FAT32 partition, to ensure that a search for deleted files would reveal as much as possible.

1/23/18, 4:14pm UTC-0800: I decided to start my investigation by attempting to address Question 1. Using a tip from Mr. Beek, I used photorec to create a dump of deleted files, searching through the entire image. Dumped files were saved to `C:\mayflower\recup_dir.1`. This directory contained a number of .png, .jpg, and .exe files:

<figure>
    <img src="/assets/img/week2/deleted-files.png">
    <figcaption>"Directory of deleted files</figcaption>
</figure>

I opened `f0011336.png`, the file that Mr. Beek noted as containing a hint. Upon opening the file, the following image appeared:

<figure>
    <img src="/assets/img/week2/hacked-by-gop.png">
    <figcaption>"Hacked by #GOP" image</figcaption>
</figure>


The URLs contained in the image were said to be key for accessing the list of usernames and passwords mentioned in Question 3. 

I next dismounted and re-mounted the disk image, choosing this time to mount Partition 0. The "Mount as removable media" option was again selected, and the drive was again mapped to `E:\`. I navigated to the `E:\` drive, and investigated its contents:

<figure>
    <img src="/assets/img/week2/drive-content.png">
    <figcaption>Contents of Partition 0 of captured disk image</figcaption>
</figure>

Mr. Beek had further hinted that:
- The targets of the attack were in the .csv file contained within the password-protected .zip drive. 
- The password for this .zip drive was located in `don't tell mrs Il Ung.jpg`. 

Using this information, I opened FileInsight to investigate `don't tell mrs Il Ung.jpg`.

1/23/18, 4:44pm UTC-0800: Opened `don't tell mrs Il Ung.jpg` with FileInsight. Using the XOR text search plugin, I selected the "View as Hex" option. I browsed through the hex dump of the file, finding the following string at offset `0x000003B0`: `pwd: infected123!`
. 

<figure>
    <img src="/assets/img/week2/pwd-il-ung.png">
    <figcaption>Password hidden in hex dump of .png file</figcaption>
</figure>

1/23/18, 4:54pm UTC-0800: I next navigated to `E:\` drive, using 7-zip to extract the .zip file contained in the same folder as `don't tell mrs Il Ung.jpg`. Prior to extraction, the password was successfully entered as `infected123!`. To avoid contaminating the drive on which I was performing my analysis, I saved the extracted .csv file to `C:\mayflower\mayflower_zip_recovered`. 

1/23/18, 5:04pm UTC-0800: Opening this .csv file with the CSV Viewer software revealed a document containing a series of comma-separated columns with fields City, Cybertarget, Website, IT support manager, CEO: 

<figure>
    <img src="/assets/img/week2/suspect-csv.png">
    <figcaption>.csv file containing attack target information</figcaption>
</figure>

A Google search reveals that GS Caltex and S-Oil are South Korean oil companies; the targets appear to be GS Caltex's Yeosu refinery and S-Oil's Onsan refinery, located in Yeosu and Ulsan, respectively. 

GS Caltex's IT support manager and CEO are also listed in this file, suggesting that they are the specific targets at GS Caltex. Following this information is a series of IP addresses that appear to correspond to specific entry paths for the attack, including network switches and FTP servers. A `whois` query on the IP address 125.135.116.33 reveals that this IP address range is owned by Korea Telecom, supporting my hypothesis.

<figure>
    <img src="/assets/img/week2/whois.png">
    <figcaption>whois query on IP address 125.135.116.33</figcaption>
</figure>

1/23/18, 5:31pm UTC -0800: Using the information provided in the .csv file, I continued by investigating the .bin file located with `don't tell mrs Il Ung.jpg` in the base folder of the disk image. 

Before my inspection of the .bin file, I accidentally clicked on the .bat file located next to it in the mounted disk image. A command prompt briefly appeared, closing itself before I could make out the message contained therein. For now, I decided to continue my investigation of the .bin file, marking this .bat file for later investigation with FlyPaper.

Upon opening the .bin file with FileInsight, I started the string search. Using Mr. Beek's hint regarding the "Hacked by #GOP" image, I performed an XOR text search using the keyword "SPEData.zip". This produced no results. I continued with ".zip" and "SPEData", both of which also produced no results. Finally, performing an XOR text search with "SPE", I found a series of passwords encrypted with XOR key `0x67`, starting at memory offset `0x0003EBBD`:

<figure>
    <img src="/assets/img/week2/spe-search-xor-067.png">
    <figcaption>Decrypted .bin file containing username/password combinations</figcaption>
</figure>

Here, I noticed the following strings, which appear to be usernames and passwords:
- Username: `Dayals-1`, Password: `London13!`
- Username: `JHKim4`, Password: `!Tomorrow`
- Username: `Kmanku-1`, Password: `M@nday77`
- Username: `MMcLean3-1`, Password: `@Smiley91`

Using this XOR key, the password for JHKim4 is somewhat garbled in the hex dump; it is possibly something  slightly different, perhaps `TomorrowTTjm4`. A `whois` query on the IP addresses that follow these usernames and passwords reveals them to be Japanese in origin; specifically, belonging to an organization in Chiyoda-Ku, Tokyo, near Sony's corporate headquarters:

<figure>
    <img src="/assets/img/week2/whois-tokyo.png">
    <figcaption>whois query on IP addresses in .bin file</figcaption>
</figure>

Mr. Beek had mentioned that these files originated in the publicly-released part of the Sony attack, and although Sony Pictures Entertainment is headquartered in Culver City, CA, it is possible that elements of Sony's corporate HQ were targeted as well.

1/23/18, 6:47pm UTC -0800: Now, I had discovered the answers to questions 1, 3 and 4; I proceeded to attempt to find answers to questions 2, 5, and 6.

I returned to the mysterious .bat file located in the E:\ directory, starting FlyPaper to prevent the command prompt from closing itself. Before running it, I copied the file to the Desktop. Next, I started FlyPaper, choosing "Block Program Exit" in the program's menu before executing. I noticed a series of error messages: it appeared that the .bat file was searching for a series of filenames and directories that it wasn't finding. Unfortunately, closing the command prompt also crashed the VM, and so I was forced to revert to a previous snapshot before continuing my analysis. 

1/23/18, 8:00pm UTC -0800 (11:00pm local time, UTC -0500): I returned to a previous, pre-analysis snapshot, re-mounted the Mayflower disk image, and, again, recovered the files on the disk with photorec. This returned me to a state pre-execution of the .bat file. I took another snapshot at 8:02pm (UTC -0800) to save a post-image mount state. All file and directory names were kept identical to their pre-crash counterparts. 

1/23/18, 8:03pm UTC -0800 (11:03pm local time, UTC -0500): Continuing with my analysis: I opened the .bin file with FileInsight, performing a string dump with the Strings plugin, searching for telling commands, filenames, or directories in the file. Immediately, I noticed a series of command-line instructions and questionably-named PE files:

<figure>
    <img src="/assets/img/week2/bin-strings.png">
    <figcaption>String dump of .bin file</figcaption>
</figure>

The commands:
- `cmd.exe /q /c net share shared$ /delete`
- `cmd.exe /q /c net share shared=%SystemRoot%` 
- `cmd.exe /q /c net share shared=%SystemRoot% /GRANT:everyone,FULL`

Are related to file/printer shares; `net share shared$ /delete` deletes the share, and `net share shared=%SystemRoot% /GRANT: everyone, FULL` gives all users full access to this network share, which is in fact the [system root folder][sys-root]. 

So, I can conclude that the malware is abusing network shares somehow. 

The filenames `RasSecruity` and `RasMgrp` are very suspicious - note the misspelling in the former. Other suspicious filenames include `diskpartmgr15.exe`, `hwrcompsvc64.exe`, and `dpnsvr16.exe`. 

Here, I elected to perform a dynamic malware analysis, using my VM along with Process Monitor, FlyPaper, and FakeNet to observe the running malware. The VM was totally isolated from outside networks, limiting the possibility of contributing to the infection; this also seemed a quicker, more direct way to observe and analyze the malware in action.

1/23/18, 8:31pm UTC -0800: With my previous snapshot in place, I began the dynamic analysis, starting Process Monitor, FlyPaper, and FakeNet. I then moved the .bin file to the Desktop, renamed it `rootkit.exe`, and executed it.

Immediately, I notice FakeNet outputting this message: 

<figure>
    <img src="/assets/img/week2/redir-socket.png">
    <figcaption>FakeNet output: attempted socket connections</figcaption>
</figure>

So, it appears that this malware is looking to connect to a socket at several IP addresses; this is being redirected by FakeNet, but the intenet is clear. Looking through Process Monitor, I notice that `rootkit.exe` is reading from itself, possibly looking for the series of usernames and passwords stored within it. 

At 8:35pm system time, it creates a second executable, named `igfxtrayex.exe`. 

1/23/18, 9:02pm UTO -0800: This investigative process was stopped when Windows Explorer crashed. Immediately before crashing, a series of `taskhost` executables were created on the Desktop (the directory from which the renamed `rootkit.exe` file had been launched). In an attempt to replicate this behavior, I returned to my saved snapshot, and re-started my analysis with only Process Monitor and FakeNet running; this was an attempt to mimic a `live` attack as much as possible, allowing programs to terminate as they wished.

Here, I investigate Process Monitor, which displays a long series of `RegOpenKey`, `RegQueryValue`, and `RegCloseKey` operations on `HKLM\System\CurrentControlSet\Services\Tcpip`; this is indicative of repeated attempts to establish a TCP connection with another network entity, as shown by FakeNet.

1/23/2018, 9:20pm UTC -0800: Finally, the `taskhost` executables are created, and Windows Explorer crashes:

<figure>
    <img src="/assets/img/week2/taskhost-killed.png">
    <figcaption>Windows Explorer crashing - note "taskhost.exe" files</figcaption>
</figure>

Looking through Process Monitor, I notice that `taskhostmw.exe` performs multiple `SetDispositionInformationFile` operations, setting Delete to True; using Process Monitor's Filter tool, I displayed only files deleted by `taskhostmw.exe`; the resulting list of deleted processes is gigantic: 

<figure>
    <img src="/assets/img/week2/taskhostmw-killed.png">
    <figcaption>taskhostmw.exe file deletions</figcaption>
</figure>

`taskhostom.exe` is analyzed in a similar fashion, using Process Monitor's Filter: notice that here, it is deleting FileInsight plugins.

<figure>
    <img src="/assets/img/week2/taskhostom-killed.png">
    <figcaption>taskhostom.exe file deletions</figcaption>
</figure>

Generally, these processes are destroying thousands (really, hundreds of thousands) of files on the target computer; it is likely that they are attempting to propagate through a local network using known access credentials (found in the .bin file analyzed above and run as `rootkit.exe`); once this process it complete, `rootkit.exe` deploys the `taskhost` executables, which destroy the content of the host's hard drive. Navigating through the C:\ drive, I notice that many executables, shortcuts, and directories have simply disappeared, with more disappearing as the analysis continues.

I was unable to obtain a memory dump, as FTK Imager had itself been deleted. 

1/23/18, 9:44pm UTC-0800: I have returned to my pre-attack snapshot. My final step in analyzing the malware was to analyze the .bin file from which my renamed `rootkit.exe` file was derived; my intent was to look for clues as to how the `taskhost` files are created, as they did not appear in a strings search or XOR text search of the .bin file itself. I did notice a string in the .bin file referencing something called inflate, written by Mark Adler; a Google search revealed that this is part of [a data compression library][inflate]. This may explain why the strings were not readily apparent.

This analysis gave me a high-level sense of the intent of the malware - it is a _wiper_, meant to propagate itself through the network, destroying files on its hosts' hard drives after it infects other connected network devices. As noted above, the credentials are likely used to gain access into the target system; the `net share` commands above are probably intended to allow the malware to be written to new hosts.  

I performed a brief amount of research using the `igfxtrayex.exe` keyword; a Google search revealed [this report][US-cert-report], created in the wake of the Sony attack, that describes in detail how the malware works. It is interesting to note that this malware will eventually overwrite the Master Boot Record, rendering the host machine inoperable. 

1/23/18, 10:02pm UTC-0800: I'm about to wrap up my investigation, although I still need to address Questions 5 and 6. 

Regarding deleted files, I noted above how the malware itself deletes a large number of files, eventually rendering the host inoperable. This behavior could be replicated after returning to a saved snapshot and re-running the malware.

There were also important deleted files on the captured disk image itself, including `f0011272.jpg`, the "Hacked by #GOP" image that revealed usernames and passwords in the malware. Investigation of other images among the deleted files reveals `f0010440.jpg`, an image of an oil refinery: 

<figure>
    <img src="/assets/img/week2/oil-refinery.png">
    <figcaption>Oil refinery image found among deleted files</figcaption>
</figure>

To a certain extent, this corroborates the information contained in the .zip file discussed above. Other DPRK-centric material (such as the image of Kim Il Sung in `f0013896.png`) supported the notion that this attack originated there.

Recommendations to the targets of this attack are similar to those developed by [US-Cert][US-cert-report]:
- Change all access credentials: usernames and passwords. 
- Move important or confidential files off of network-connected equipment.
- Update operating systems and software, making sure that all known security patches are installed.
- Consider hiring penetration testers to analyze any other weak points in security infrastructure. 
- Consider improving or upgrading AV protection.  
- Limit network connectivity of critical refinery equipment. Ensure that any computers tasked with monitoring or controlling refinery equipment are fully secured and as isolated as possible. 

### Conclusions

In summary, I can conclude that:

1. The targets of the attack are two South Korean oil refineries, GS_Caltex's Yeosu Refinery, and S-Oil's Onsan Refinery. Specific targets at GS-Caltex have been identified as Kant P. Rajani, IT support manager, and Akhil Kumar Rajesh Nagar, CEO. 
2. The malware attack works by using valid usernames and passwords to gain access to computers on the company's network, replicating itself onto other network-connected devices before wiping the contents of the host's hard drive, rendering it inoperable. 
3. A list of usernames and passwords could be found in the .bin file located within the main partition of the captured disk image; these can be viewed above.
4. Usernames and passwords were found at memory offset `0x0003EBBD` in the .bin file.
5. Deleted files could be restored using photorec, and contained useful supporting data, along with key clues used for decrypting the malware used in the attack. The malware itself deletes numerous system and user files, eventually re-writing the Master Boot Record, making the host computer inoperable. This behavior could be replicated by using memory snapshots to return to a pre-infection state.
6. Recommendations for the users include improving AV protection, changing all access credentials, moving important or confidential files off of network-connected equipment, updating operating systems and applications with recent security patches, and hiring teams of penetration testers to identify any vulnerabilities.


That's all for this week. Mr. Beek has ridden off into the sunset, and we begin next week with a study of malware defense techniques. Should be interesting. I've learned an incredible amount in the last two weeks, and am looking forward to the next eight.

[rfc-3327]: https://www.ietf.org/rfc/rfc3227.txt
[vol-docs]: https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#getsids
[vol-blog]: https://volatility-labs.blogspot.com/2012/09/movp-13-desktops-heaps-and-ransomware.html
[mft]: https://msdn.microsoft.com/en-us/library/windows/desktop/aa365230(v=vs.85).aspx
[sys-root]: https://en.wikipedia.org/wiki/Environment_variable
[US-cert-report]: https://www.us-cert.gov/ncas/alerts/TA14-353A
[inflate]: https://github.com/madler/zlib